Встраиваемая минималистичная Форт-система.

Реализована на ANSI C99 и предназначена для встраивания в программы на языках C и C++.

Безопасные операции работы с памятью, контроль и диагностика ошибок. Имеется отключаемая возможность сохранения полного состояния системы, только программы с указанием точки входа или только области данных.

Области памяти:
	- стек данных (доступ из программы через слова работы со стеком)
	- стек возвратов (служебный)
	- стек циклов (служебный)
	- словарь (доступ из программы через определяющие слова)
	- область имён (доступ из программы через определяющие слова)
	- область кода (доступ из программы через компилирующие слова)
	- область данных (доступ из программы через слова работы с памятью)

Словарь представляет собой массив словарных статей. Названия слов помещаются в область имён с нулевым байтом после каждого слова. Специальное поле в словарной статье содержит смещение в области имён, с которого начинается название соответствующего слова.
Область кода имеет поячеечную адресацию (ячейка - int), в неё помещаются номера примитивов и параметры слов.
Область данных имеет побайтовую адресацию, в ней хранятся обрабатываемые программой данные.
Эти четыре области образуют четыре раздельных адресных пространства, их размеры задаются макросами на этапе компиляции.

Текстовый интерпретатор реализован на Си и может быть отключен при сборке макросом FORTH_ONLY_VM. При этом также отключается словарь с пространством имён и все примитивы, работающие с ними и с исходным текстом программы.

Поиск слов осуществляется в контекстном словаре. Словари сцепляются между собой при создании. Если слово не найдено в контекстном словаре, то выполняется поиск в его базовом словаре и т.д.

Слова в машинном коде (примитивы) кодируются целыми числами и при выполнении скомпилированных определений обрабатываются оператором switch. При инициализации системы ей в качестве параметра передаётся адрес функции, обрабатывающей примитивы хост-программы.

Обработка ошибок осуществляется с использованием функций setjmp() и longjmp(). Хост-программа инициализирует буфер с контекстом выполнения функцией setjmp() перед вызовом любых функций API системы и передаёт его адрес функции инициализации. При возникновении ошибки происходит переход на обработчик ошибок с использованием этого контекста. Код обработки ошибки может получить подробную информацию о типе ошибки, месте её возникновения и данных на стеке.


Встроенные слова:

Слово			Стековая диаграмма		Описание
=====			==================		========
		( Управление выполнением программы )
EXIT			--				Выход из текущего определения
DO			HI LO --			Начало цикла со счётчиком
?DO			HI LO --			Начало цикла со счётчиком. Если пределы равны, то переход на конец цикла
LOOP			--				Конец цикла со счётчиком, приращение счётчика на 1
+LOOP			N --				Конец цикла со счётчиком, приращение счётчика на N
IF			? --				Начало условного оператора
ELSE			--				Начало альтернативной ветви условного оператора
THEN			--				Конец условного оператора
BEGIN			--				Начало условного цикла
UNTIL			? --				Конец цикла с постусловием, цикл выполняется пока условие ложно
AGAIN			--				Конец безусловного цикла
WHILE			? --				Конец условия в цикле с предусловием, тело цикла выполняется пока условие истинно
REPEAT			--				Конец тела цикла с предусловием
LEAVE			--				Выход из цикла со счётчиком
I			-- N				Получение значения счётчика цикла
J			-- N				Получение значения счётчика внешнего цикла
:			"WORD" --			Начало определения через двоеточие
;			--				Конец определения через двоеточие
EXECUTE			XT --				Выполнение слова по его токену
TRY			"WORD" -- ?			Выполнение указанного слова с перехватом ошибок. Возвращает истину, если слово выполнилось успешно, и ложь - в противном случае. Глубина стека под возвращаемым флагом равна глубине стека до выполнения слова
ERROR			S --				Сгенерировать ошибку с сообщением S

		( Арифметические операции )
+			N N -- N			Сложить
-			N N -- N			Вычесть
*			N N -- N			Умножить
/			N N -- N			Разделить нацело
MOD			N N -- N			Вычислить остаток от деления
/MOD			N N -- N N			Деление с остатком (частное на вершине стека)
NEGATE			N -- N				Изменить знак числа
1+			N -- N				Прибавить 1
1-			N -- N				Вычесть 1
CELL			-- N				Получить размер ячейки в байтах
CELLS			N -- N				Получить размер указанного количества ячеек в байтах
CELL+			N -- N				Прибавить размер ячейки в байтах
CELL-			N -- N				Вычесть размер ячейки в байтах
MIN			N N -- N			Найти наименьшее из двух чисел
MAX			N N -- N			Найти наибольшее из двух чисел
ABS			N -- N				Найти модуль числа

		( Операции со стеком )
SWAP			A B -- B A			Поменять два элемента местами
DUP			A -- A A			Дублировать элемент на стеке
DROP			N --				Удалить элемент со стека
ROT			A B C -- B C A			Вращать три верхних элемента стека по часовой стрелке
-ROT			A B C -- C A B			Вращать три верхних элемента стека против часовой стрелки
TUCK			A B -- B A B			Поместить копию верхнего элемента стека под второй элемент
OVER			A B -- A B A			Копировать второй элемент стека на вершину
NIP			A B -- B			Удалить второй элемент стека
2DUP			A B -- A B A B			Дублировать два элемента стека
2DROP			A B --				Удалить два элемента стека
?DUP			A -- A A | 0 -- 0		Дублировать элемент, если он ненулевой

		( Логические операции )
AND			N N -- N			Побитовое И
OR			N N -- N			Побитовое ИЛИ
NOT			N -- N				Побитовое НЕ
XOR			N N -- N			Побитовое исключающее ИЛИ
<			N N -- ?			Меньше
<=			N N -- ?			Меньше или равно
>			N N -- ?			Больше
>=			N N -- ?			Больше или равно
=			N N -- ?			Равно
<>			N N -- ?			Не равно
0<			N N -- ?			Меньше 0
0>			N N -- ?			Больше 0
0=			N N -- ?			Равно 0
0<>			N N -- ?			Не равно 0
FALSE			-- ?				Ложное значение
TRUE			-- ?				Истинное значение
WITHIN			N LO HI -- ?			Определить лежит ли N в диапазоне [LO,HI)
BETWEEN			N LO HI -- ?			Определить лежит ли N в диапазоне [LO,HI]

		( Операции с данными и памятью )
CONSTANT		"WORD" N --			Определить константу со значением N
VARIABLE		"WORD" --			Определить переменную и инициализировать её 0
@			A -- N				Считать ячейку по адресу A
!			N A --				Записать значение N в ячейку по адресу A
C@			A -- C				Считать байт по адресу A
C!			C A --				Записать значение С в байт по адресу A
,			N --				Скомпилировать ячейку в область данных
C,			C --				Скомпилировать байт в область данных
CREATE			"WORD" --			Создать слово, возвращающее указатель на область данных
DOES>			--				Начать описание семантики выполнения для последнего слова, созданного через CREATE
+!			N A --				Прибавить N к значению ячейки по адресу A
VALUE			"WORD" --			Определить величину и инициализировать его 0
TO			"WORD" N --			Установить значение величины
HERE			-- А				Получить адрес начала свободного пространства в области данных
ALLOT			N --				Выделить N байт в области данных
>DATA			XT -- A				Получить адрес области данных для слова, созданного через CREATE
MOVE			SRC DST N --			Скопировать N байт в области данных начиная с адреса SRC по адресу DST
FILL			SRC N C --			Заполнить N байт в области данных начиная с адреса SRC байтом C
ERASE			SRC N --			Занулить N байт в области данных начиная с адреса SRC

		( Компиляция )
CODE,			N --				Скомпилировать ячейку в область кода
COMPILE			"WORD" --			Скомпилировать код компиляции указанного слова
[COMPILE]		"WORD" --			Скомпилировать указанное слово
'			"WORD" -- XT			Получить токен указанного слова
[']			"WORD" --			Скомпилировать токен указанного слова как литерал
IMMEDIATE		--				Сделать последнее определённое слово словом немедленного исполнения
STATE			-- N				Получить состояние системы, FALSE - интерпретация, TRUE - компиляция
]			--				Перейти в режим компиляции
[			--				Перейти в режим интерпретации
{			-- XT				Начать безымянное определение
}			XT --				Завершить безымянное определение и выполнить его
#CODE			-- N				Получить размер скомпилированного кода в ячейках
#DICT			-- N				Получить количество словарных статей в словаре
#NAMES			-- N				Получить размер названий слов в байтах

		( Разбор исходного текста и вспомогательные слова )
(			"STRING<)>"			Блочный комментарий до следующей неэкранированной закрывающей скобки
\\			"STRING<EOL>"			Строковый комментарий до следующего неэкранированного перевода строки
CHAR			"WORD" -- C			Получить или скомпилировать в определение в качестве литерала код первого символа указанного слова
"			"STRING<">" -- S		Скомпилировать в область данных строку с завершающим нулевым байтом до первой неэкранированной двойной кавычки. На стек помещается адрес первого символа строки
DEPTH			-- N				Получить количество элементов на стеке
LENGTH			S -- N				Получить длину строки в байтах
COUNT			S -- S N			Получить длину строки в байтах, оставив адрес строки на стеке
BL			-- С				Код символа "пробел"
STRING			"STRING<C>" C -- S		Выделить из входного потока строку до первого неэкранированного символа C, скомпилировать её в область данных с завершающим нулевым байтом и поместить на стек адрес первого символа
WORD			"WORD<C>" C -- S		Выделить из входного потока слово, используя символ C как разделитель, и поместить его в начало свободной части области данных, не перемещая её указатель
VOCABULARY		"WORD" --			Определить новый словарь для которого базовым будет текущий словарь. При выполнении словаря он становится контекстом поиска слов
DEFINITIONS		--				Сделать контекстный словарь текущим, в него будут добавляться новые определения

		( Сохранение состояния системы )
SAVE			S --				Сохранить полное состояние системы в файл с именем S
LOAD			S --				Загрузить полное состояние системы из файла с именем S
SAVE-PROGRAM		S XT --				Сохранить области кода и данных в виде программы с точкой входа в слове XT
SAVE-DATA		S --				Сохранить область данных в файл с именем S
LOAD-DATA		S --				Загрузить область данных из файла с именем S


Функции API:

void fth_error(const char *fmt, ...)
   Остановить выполнение программы с сообщением об ошибке, формируемым из строки формата fmt и дополнительных значений, аналогично функции sprintf().

void fth_push(int x)
   Поместить значение в стек.

int fth_pop(void)
   Получить значение из стека.

int fth_fetch(int a)
   Считать ячейку из области данных по адресу a.

void fth_store(int a, int x)
   Записать значение x в ячейку области данных с адресом a.

char fth_cfetch(int a)
   Считать байт из области данных по адресу a.

void fth_cstore(int a, char x)
   Записать байт x в область данных по адресу a.

char *fth_area(int a, int size)
   Проверить корректность участка области данных, начинающегося с адреса a, длиной size байт и вернуть указатель на него.

void fth_init(primitives_f app_primitives, jmp_buf *errhandler)
	Инициализировать Форт-систему. app_primitives - функция, обрабатывающая примитивы приложения. Она должна вызывать fth_error(), если примитив не распознан. errhandler - адрес контекста обработки ошибок, установленного с помощью setjmp(); контекст впоследствии может быть переназначен другими вызовами setjmp().

void fth_interpret(const char *s)
   Интерпретировать текст программы на Форте.

void fth_execute(const char *w)
   Выполнить слово w.

void fth_primitive(const char *name, int code, int immediate)
   Объявить слово-примитив с именем name, кодом code. Если immediate ненулевое, то для объявляемого слова устанавливается флаг немедленного исполнения.

void fth_library(primitive_word_t *lib)
   Объявить примитивы по таблице, состоящей из инициализаторов структур primitive_word_t. Таблица должна завершаться иницилизатором с полем name, установленном в NULL.

void fth_reset(void)
   Сбросить состояние Форт-системы: установить состояние интерпретации, очистить все стеки, установить контекстный и текущий словарь в системный словарь и очистить сообщение о последней ошибке.

const char *fth_geterror(void)
   Получить сообщение о последней ошибке. NULL, если ошибки не было.

int fth_getdepth(void)
   Получить количество элементов на стеке.

int fth_getstack(int idx)
   Получить элемент стека с указанным индексом: 0 - нижний элемент стека, fth_getdepth() - 1 - вершина стека. Возвращает 0, если индекс некорректный.

int fth_getstate(void)
   Получить текущее состояние системы: 0 - интерпретация, ~0 - компиляция.

const char *fth_geterrorline(int *plen, int *pintp, int *plineno)
   Получить информацию о месте возникновения ошибки в исходном тексте. Возвращает указатель на начало строки, в которой произошла ошибка. В plen помещается длина строки, в pintp - смещение места возникновения ошибки от начала строки, в plineno - номер строки в исходном тексте. Если исходный текст отсутствует, то функция возвращает NULL, а содержимое plen, pintp и plineno не изменяется.

int fth_gettracedepth(void)
   Получить глубину вложенности вызовов.

const char *fth_gettrace(int idx)
   Получить слово на указанной глубине вложенности вызовов (0 - самое первое вызванное слово, fth_gettracedepth() - 1 - текущее слово). Возвращает строку "<unknown>", если слово определить не удалось (вызывалось безымянное определение или слово находится за в другом контексте). Возвращает строку "<invalid backtrace index>" при передаче некорректной глубины.

void fth_savesystem(const char *fname)
   Сохранить полное состояние системы в файл с указанным именем. Файл состояния совместим с другими Форт-системами при одновременном соблюдении следующих условий:
      - у систем совпадают размеры int;
      - у систем совпадает порядок байт (endianness);
      - у систем совпадают количество и коды примитивов (семантика может отличаться);
      - загружающая система имеет достаточные размеры областей памяти, чтобы вместить сохранённую систему.

void fth_loadsystem(const char *fname)
   Загрузить состояние системы из файла с указанным именем.

void fth_saveprogram(const char *fname, const char *entry)
   Сохранить области кода и данных в файл в именем fname с указанной точкой входа entry (название слова).

void fth_runprogram(const char *fname)
   Загрузить области кода и данных из файла с указанным именем и запустить на исполнение с сохранённой точки входа. Для этой функции текстовый интерпретатор может отсутствовать.

void fth_savedata(const char *fname)
   Сохранить область данных в файл с указанным именем.

void fth_loaddata(const char *fname)
   Загрузить область данных из файла с указанным именем.

